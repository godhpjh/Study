

# 넷마블펀 면접 준비

### 해야할 항목 정리

1. #### 자기소개

   - 장점, 단점

   ```
   예시] 
   예시) 안녕하십니까! 지원자 이학진입니다.
   저는 넷마블펀의 신입사원이 되기 위해 두가지 히든카드를 준비했습니다.
   첫 번째 집요한 끈기입니다. 마주한 오류와 버그를 해결하기 위해 하루, 이틀이든 물고 늘어지는 집요한 끈기를 지니고 있습니다. 삼성 청년 SW 아카데미 프로젝트 중 이러한 끈기로 프로님과 코치님에게 인정받아 우수교육생으로 선발된 경험과 프로젝트 우수상의 성과를 낸 경험이 있습니다. 
   두번 째 강한 책임감입니다. 열정이 많다고 해도 일에 대한 권태기가 오기 마련입니다. 그런 상황에서 책임감 없이 도망친다면 열정은 아무 소용이 없습니다. 이런 면에서 무엇보다도 시작한 일은 끝을 봐야하는 저의 책임감은 제 열정을 뒷받침 할 것입니다.
   이 준비한 2가지 히든카드로 넷마블펀 성장에 기여하고 싶은 지원자 이학진입니다. 감사합니다.
   ```
   
2. #### 자료구조

   - #### 정렬

     - 참고사이트 : https://gmlwjd9405.github.io/2017/10/01/basic-concepts-of-development-algorithm.html

   - 손코딩, 의사코드(pseudo-code)
   
   - #### 스택
   
     - 배열 스택 구현 : https://freestrokes.tistory.com/82
  - 입력과 출력이 한 곳(방향)으로 제한
     - LIFO (후입선출) : 가장 나중에 들어온 것이 가장 먼저 나옴
     - 함수의 콜스택, 문자열 역순 출력, 연사자 후위표기법에서 사용된다.
     - new 연산자로 객체를 생성하여 사용 가능

     ```
    Stack st = new Stack();
    ```
   
- #### 힙
  
  - **완전 이진 트리의 일종**으로 우선 순위 큐를 위하여 만들어진 자료구조
    
  - 최대 힙, 최소 힙
    
   - #### 큐
  
     - 배열 원형 큐 구현 : [https://hongpossible.tistory.com/entry/Java-%EC%9B%90%ED%98%95-%ED%81%90-%EA%B5%AC%ED%98%84](https://hongpossible.tistory.com/entry/Java-원형-큐-구현)
     - 큐 구현 : https://hyeonstorage.tistory.com/263
     - 입력과 출력을 한 쪽 끝(front, rear)으로 제한
     - FIFO(선입선출) : 가장 먼저 들어온 것이 가장 먼저 나옴
     - 버퍼, 마구 입력된 것을 처리하지 못하고 있는 상황, BFS에서 사용된다.
     - 삽입의 경우는 rear로 들어가지만, 출력의 경우 front부터 빠진다.
     - LinkedList에 new 연산자로 객체를 생성함으로서 사용 가능
     
     ```
     Queue que = new LinkedList<>();
     ```
     
     

# CS (프로그래밍 지식)

## Vector 클래스

- 배열의 고정적인 크기를 보완한 클래스, 동적인 길이로 여러 데이터형을 저장하기 위해 Vector 클래스를 제공한다. 
- 가변 길이의 배열이라고 할 수 있다.
- 무조건 동기화한다 => 단일 쓰레드 처리에서 성능이 떨어진다

## Collection

![img](https://github.com/WeareSoft/tech-interview/raw/master/contents/images/java-collections-framework.png)

## Array

- 선언 시 크기와 데이터 타입을 지정해야 한다.
- 고정적인 크기를 같는 배열
- index로 빠르게 값을 찾는 것이 가능하다.

## Array와 ArrayList의 차이점

- 둘다 배열이라는 점은 동일
- Array는 index로 접근하는 반면, ArrayList는 메서드를 통해 접근한다.
- 또한 Array는 Object뿐만 아니라 원시(Primitive 타입)도 담을 수 있지만
- ArrayList는 Object형(Reference, 객체)만 담을 수 있다. 
  따라서 정수를 ArrayList에 넣을 경우 Integer형은 가능하지만 int형은 안된다. 
+ Integer처럼 int와 같은 원시타입을 담을 수 있는 객체를 Wrapper Class라고 한다.

## Set

- 객체를 순서 없이 저장하는 데이터의 집합, 같은 데이터는 무시된다. ( equals(), hashCode() 비교)

- #### HashSet

  - HashMap에서 key값이 없는 자료형. 
  - 집합이라고 생각해도 무방하다. 
  - 값이 포함되어 있는지 아닌지만 관심이 있다. 
  - 순서를 보장하지 않으며, 중복값을 허용하지 않는다. Set중에는 가장 많이 사용된다.
  - hash algorithm을 사용하여 검색 속도가 매우 빠르다.

- #### TreeSet

  - SortedSet을 구현한 클래스
  - Red-Black Tree 자료구조를 사용한 Set
  - binary search tree 형태로 객체 저장
  - Comparator의 구현으로 sort 방법 지정 가능

- #### LinkedHashSet

  - LinkedList로 구현된 HashSet으로 순서를 보장한다.
  - 저장 순서를 유지하는 HashSet 클래스

## List

- 객체를 순서대로 저장하고, 인덱스를 부여한다.
- 중복된 데이터도 새로운 인덱스를 부여하여 저장한다.

- #### ArrayList

  - 각 데이터에 대한 인덱스를 가지고 있어 각 데이터의 접근이 빠름

  - 데이터 삽입, 삭제시 다소 느림

    (해당 데이터 이후 모든 데이터가 복사되어야 하기 때문)

- #### LinkedList

  - 데이터 삽입, 삭제시 앞뒤 포인터만 연결해 주면 되므로 속도가 빠름
  
  - 데이터 검색시 다소 느림
  
    (처음부터 노드를 순회해야 하기 때문)

## Map

- 객체 저장, 관리 시에 검색을 보다 쉽게 하기 위해 구현된 인터페이스
- 객체를 Key와 Value로 구분하여 관리한다.
- Key를 통해 검색과 삭제를 쉽게 할 수 있다.

- #### HashMap

  - 가장 일반적으로 사용하는 Map. 
  - HashTable을 사용, Key값에 해시함수를 적용하여 나온 index에 Value를 저장하는 방식. 
  - 중복성을 허용하지 않으며 순서가 없다는 것이 특징
  - 시간복잡도 : O(1)

- #### TreeMap

  - Red-Black Tree 자료구조를 이용한 Map이다. 
  - Tree 구조이기 때문에 어느 정도 순서를 보장한다.
  - 키값이 기본적으로 오름차순 정렬되어 출력된다.
  - 키값에 대한 Compartor 구현으로 정렬 방법을 지정할 수 있다.
  - 시간복잡도 : O(logn)

- #### LinkedHashMap

  - LinkedList로 구현된 HashMap이다. 
  - List로 구현되어있기 때문에 순서가 보장된다.
  - 하지만 LinkedList 특성상 랜덤 접근에서 느릴 수 있다.
  - 입력 순서대로 출력된다.
  - 시간복잡도 : O(n)

## String, StringBuilder, StringBuffer 차이점

참고 : https://12bme.tistory.com/42

- #### String

  - 새로운 값을 할당할 때마다 새로 클래스에 대한 객체가 생성된다.
  - String에 저장되는 문자열은 private final char[]의 형태이기 때문에 String 값은 바꿀수 없다.
  - String + String + String.. 의 형태
    - 각각의 String 주소값이 Stack에 쌓이고, GC가 호출되기 전까지 생성된 String 객체들은 Heap에 쌓이기 때문에 메모리 관리에 치명적이다.

- #### StringBuilder

  - Memory에 append하는 방식으로, 클래스에 대한 객체를 직접 생성하지 않는다.
  - 변경가능한 문자열
  - 비동기 처리

- #### StringBuffer

  - Memory에 append하는 방식으로, 클래스에 대한 객체를 직접 생성하지 않는다.
  - 변경가능한 문자열
  - 동기 처리
  - 멀티쓰레드 환경에서 안전한 클래스(thread safe)

## Wrapper Class

- Java의 기본형 데이터 타입을 객체화 시키는 클래스
- Integer, Short, Byte, Long, Float, Double 등

#### AutoBoxing & UnBoxing

- AutoBoxing
  - primitive 타입의 데이터를 자동으로 wrapper class의 객체로 변환하는 과정
- Unboxing
  - wrapper class 타입의 데이터를 primitive 타입으로 변환하는 과정

```
AutoBoxing 의 예
// Integer Wrapper Class 에 primitive type의 123을 컴파일러가 자동으로 Boxing
Integer integer = 123;

// 위에서 생겨난 Wrapper Integer를 int 타입에 자동으로 unBoxing
int primitive = integer
```



## Modifier

#### Access Modifier(접근 제한자)

- public : 프로젝트 내 모든 클래스에서 접근 가능
- protected : 같은 패키지, 상속받은 자식 클래스에서 접근 가능
- (default) : 같은 패키지 내의 클래스에서 접근 가능
- private : 해당 클래스 내에서만 접근 가능

#### Usage Modifier(접근 제한자 이외의 모든 제한자)

- static : 멤버 변수, 멤버 method, 멤버 nested class
  - static variable : 객체 생성 없이 사용 가능 => 해당 클래스를 인스턴스화한 객체들 간의 공용변수로 사용
  - static method 
    - 객체 생성 없이 사용 가능
    - static variable과 method만 사용 가능하다.
    - 인스턴스가 생성되지 않았을 때도 호출 가능하기 때문에 this, super 변수는 사용 불가하다.
    - overriding 불가
- final : class, variable, method
  - final class : 상속 받을 수 없음
  - final variable : 상수
  - final method : overriding 불가
- abstract : class, method
  - abstract class
    - 최소 한개 이상의 추상메서드를 포함하는 클래스 또는 abstract로 선언된 클래스



## Static의 의미

1. 클래스를 설계할 때, 멤버변수 중 **모든 인스턴스에 공통적으로 사용해야하는 것**에 static을 붙여 사용한다. 

- 인스턴스를 생성하면, 각 인스턴스들은 서로 독립적이기 때문에 서로 다른 값을 유지한다. 
- 경우에 따라서 각 인스턴스들이 공통적으로 같은 값이 유지되어야 하는 경우 사용한다.

2. static이 붙은 멤버변수는 **인스턴스를 생성하지 않아도 사용**할 수 있다.

- static이 붙은 멤버변수(클래스변수)는 클래스가 메모리에 올라갈때 이미 자동적으로 생성되기 때문이다.

3. static이 붙은 **메서드에서는 인스턴스 변수를 사용할 수 없다.**

- static 메서드는 인스턴스 생성 없이 호출가능한 반면, 인스턴스 변수는 인스턴스를 생성해야만 존재하기 때문에 static이 붙은 메서드를 호출할 때 인스턴스가 생성되어있을수도 그렇지 않을 수도 있어서 static이 붙은 메서드에서 인스턴스 변수의 사용을 허용하지 않는다.

4. **메서드 내에서 인스턴스 변수를 사용하지 않는다면**, static을 붙이는 것을 고려한다.

- 메서드의 작업내용 중에서 인스턴스 변수를 필요로 한다면, static을 붙일 수 없다. 반대로 인스턴스 변수를 필요로 하지 않는다면, 가능하면 static을 붙이는 것이 좋다. 메서드 호출시간이 짧아지기 때문에 효율이 높아진다.

5. 클래스 설계시 static의 사용지침

- 먼저 클래스의 멤버변수 중 모든 인스턴스에 공통된 값을 유지해야하는 것이 있는지 살펴보고 있으면, static을 붙여준다.
- 작성한 메서드 중에서 인스턴스 변수를 사용하지 않는 메서드에 대해서 static을 붙일 것을 고려한다.



## 추상클래스와 인터페이스 차이

- #### 컴파일 시 추가되는 Modifier
  - variable : public static final
    - 인터페이스에는 상수만 정의될 수 있다.(객체 생성이 불가능하기 때문)
  - method : public abstract
    - 인터페이스의 모든 method는 abstract method이다.
    - 구현 클래스에서 overriding시 메소드는 항상 public 제한자를 가져야 한다.

- #### 인터페이스

  - 일종의 추상 클래스. 오직 추상메서드와 상수만을 멤버로 갖는다.
  - implements 키워드를 사용하며 다중 상속이 가능하다.
  - 상속의 관계가 없는 클래스간 서로 공통되는 로직을 구현하여 쓸 수 있도록한다.
    (구현 객체의 같은 동작을 보장하기 위함)
  - 자바 8 버전부터 디폴트 메서드(default method) 지원
    - 디폴트 메서드의 목적은 기존 인터페이스 기능을 확장하며, 
      구현체에 공통적으로 들어갈 기능(코드)를 디폴트 메서드 내부에 작성함으로써 반복되는 코드의 작성을 줄여준다
  
- #### 추상클래스

  - 추상메서드를 자식 클래스가 구체화하여 그 기능을 확장하는데 목적이 있다.
  - 추상메서드를 하나 이상 가진 클래스
  - 자신의 생성자로 객체 생성 불가능하다
  - 하위 클래스를 참조하여 상위 클래스의 객체를 생성가능 하다.
  - 하위 클래스를 제어하기 위해 사용
  
- #### 공통점

  - new 연산자로 인스턴스 생성이 불가능하다.
  - 프로토타입만 있는 메서드를 갖는다.
  - 사용하기 위해서는 하위클래스에서 확장/구현 해야한다.

- #### 차이점

  - 추상클래스는 `is a kind of` 인터페이스는 `can do this`
  - 추상클래스는 단일 상속, 인터페이스는 다중 상속 가능
  - 서로 다른 목적을 가지고 있다.
  - 사용하는 키워드가 다르다.
  - 추상클래스는 일반 메서드를 사용할 수 있지만, 인터페이스는 메서드 선언만 가능하다.

## JVM(Java Virtual Machine)

- 자바 애플리케이션을 클래스 로더를 통해 읽어 들여 자바 API와 함께 실행하는 것
- Java와 OS사이에서 중개자 역할을 수행하여 JAVA가 OS에 구애받지 않고 재사용을 가능하게 해준다.

![img](https://k.kakaocdn.net/dn/TQ5Md/btqy1Jy5Y9L/NzJUqAijokDiCaNhwPO5iK/img.png)



#### Method Area(Class Area)

- class 파일의 바이트코드가 로드되는 영역
- 즉, JVM이 읽어 프로그램을 실행할 수 있는 '프로그램의 흐름을 구성하는 바이트코드'가 존재한다.
- class정보(생성자, 메소드, static 변수, 멤버 변수), runtime constant pool 저장

#### Heap Area

- **런타임**시 동적으로 메모리를 할당하여 사용하는 영역
- new 연산자로 생성된 객체와 배열을 저장한다.
- 해당 메모리를 참조하는 변수나 필드가 없다면 GC의 대상이 된다.

#### Stack Area

- 각 스레드마다 하나씩 존재하며, 스레드 시작시 할당되는 영역
- 메소드 정보(지역변수, 매개변수 등) 저장
- primitive 타입 변수는 스택 영역에 직접 값을 가지고, reference 타입 변수는 힙 영역이나 메소드 영역의 객체 주소를 가진다.

#### PC Register

- 현재 수행중인 JVM 명령 주소를 가짐

#### Native Method Stack Area

- 자바 외 언어로 작성된 네이티브 코드를 위한 영역
- 즉, JNI(Java Native Interface)를 통해 호출되는 코드를 수행하기 위한 스택
- 참고 : https://hoonmaro.tistory.com/19

## GC(Garbage Collection)

#### Heap 메모리 영역 

- Young
  - Eden : 새로 생성된 객체가 저장되는 부분
  - Survivor 0
  - Survivor 1
- Old
- Permanent

#### Minor GC

- Eden 영역이 가득차게 되면 GC가 한번 발생하고, 살아남은 객체는 Survivor 영역 중 하나로 이동된다.
- Survivor 영역은 두 영역을 동시에 사용하지 않고 둘 중 한영역만 번갈아서 사용한다.
  - Eden영역에서 살아남은 객체를 Survivor 영역으로 옮길 때, 기존 사용중이던 Survivor 영역의 객체들도 모두 다른 Survivor 영역으로 옮긴다. 
  - Survivor 영역에서 다른 Survivor 영역으로 이동할 때 age값이 증가된다.
  - 모든 객체가 옮겨지면 기존 사용중이던 Survivor영역과 Eden 영역은 클리어된다.
  - 이 과정을 반복하다가 일정 시간 이상 살아남아 있는 객체는 Old 영역으로 이동된다.(Promotion)

#### Major GC

- Old 영역에 있는 모든 객체들을 검사하여 참조되지 않은 객체들을 한꺼번에 삭제한다.
- `stop-the-world` : 시간이 오래걸리는 작업으로, GC 스레드를 제외한 모든 스레드 작업을 멈춘 후 수행한다.

#### GC 동작 원리

- heap 메모리 내의 모든 객체들 중 참조되고 있지 않은 객체를 찾아 소멸시킨다.

- 이때, 참조되고 있는 객체 판단을 위해 reachability 라는 개념을 사용한다.

  - 유효한 참조가 있으면 reachability, 없으면 unreachability로 판단한다.
  - 참조되고 있는 객체는 다음 4가지 경우로 나눌 수 있다.
    - heap 내의 다른 객체에 의한 참조
    - Stack Area의 지역변수, parameter에 의한 참조
    - JNI 네이티브 스택에 의해 생성된 객체에 의한 참조
    - Method Area의 static 변수에 의한 참조
  - 위 4가지 경우 중 2,3,4번은 참조를 시작한 곳으로, 이를 root set이라고 부른다.
  - 결국 root set에 도달하지 못하는 객체들(Unreachable)은 GC의 대상이 되는 것이다.

  ![javareference2](https://d2.naver.com/content/images/2015/06/helloworld-329631-2.png)

- ##### `mark and sweep` 

  - mark : 모든 객체를 스캔하면서 참조되고 있지 않은 객체를 찾는 과정
  - sweep : mark 되어있지 않은 객체들을 힙에서 제거하는 과정

- 참고 : https://asfirstalways.tistory.com/159

  ​           https://yaboong.github.io/java/2018/06/09/java-garbage-collection/

## 오버로드 와 오버라이딩의 차이

- #### 오버라이딩

  - 상속에서 나온 개념으로 상위 클래스(부모)의 메서드를 하위 클래스(자식)에서 재정의

- #### 오버로딩

  - 같은 이름의 메서드를 여러개 정의하는 것
  - 매개변수의 타입이 다르거나 개수가 달라야 한다.

- #### Method Overriding  규칙

  - Exception throws 규칙
    - 상위 클래스에서 throws한 예외의 범위를 넘지 않아야 한다.
      - 상위 클래스에서 throws한 예외의 Sub Exception을 던지거나 같은 Exception을 던진다.
      - 예외를 throws하지 않는다.
      - Runtime Exception을 던진다.(상위 클래스와 관계 없음)
  - Access Modifier 규칙
    - 상위 클래스의 Access Modifier와 같거나 더 넓은 범위의 Access Modifier로 선언해야 한다.
  - Method 이름, Return type, Parameter는 같아야 한다.

- #### Method Overloading 규칙

  - method 이름은 같아야 한다.
  - parameter 규칙
    - 개수 또는 데이터 타입이 달라야 한다.
  - 그 외는 상관없음



## 세션과 쿠키 차이점

- 참고 : https://ryusae.tistory.com/7
- 쿠키와 세션의 차이점은 크게 **상태 정보의 저장 위치**이다. 
- 쿠키는 '클라이언트(= 로컬 = 사용자브라우저)'에 저장
- 세션은 '서버' 에 저장

#### 쿠키

- 클라이언트는 총 300개의 쿠키를 저장할 수 있음

- 하나의 도메인 당 20개의 쿠키를 가질 수 있음 -> 20개가 넘으면 가장 적게 사용되는 것부터 삭제됨

- 하나의 쿠키는 4KB (4096byte) 저장 가능
- 만료 기간 지정, 브라우저 종료 시에도 유지 
- 자동 로그인 유지, 위시 리스트 저장, 팝업 보지 않기, 사용자 이전 스크롤링이나 뷰 설정 값 등

- ##### 통신 방법

  1. 최초 통신에서는 쿠키값이 없으므로, 일단 클라이언트는 Request 를 한다.

  2. 서버에서 클라이언트가 보낸 Request Header에 쿠키가 없음을 판별. 

  ​    통신 상태(UserID, Password, 조작상태, 방문횟수 등)를 저장한 쿠키를 Response한다.

  3. 클라이언트의 브라우저가 받은 쿠키를 생성/보존한다

  4. 두번째 연결부턴, HTTP Header에 쿠키를 실어서 서버에 Request 한다

#### 세션

- 로그인 정보 유지 시 사용된다.
- 브라우저 종료시 삭제 (기간 지정이 가능하긴 함)

- ##### 통신 방법

  1. 클라이언트가 서버에 접속 시, 세션 ID를 발급한다.

  2. 서버에서는 클라이언트로 발급해준 세션 ID를 쿠키를 이용해서 저장

  3. 클라이언트는 다시 페이지에 접속할 때, 쿠키에 저장된 세션 ID를 서버에 전달

  4. 서버는 Request Header에 쿠키 정보(세션 ID)로 클라이언트를 판별

- ##### SESSION ID 보안의 취약점

  - 세션 해킹
    - 홈페이지 관리자의 세션 아이디를 탈취 
      -> 쿠키값을 관리자의 세션아이디로 변경한다. -> 관리자 권한으로 이용 

  - 예방법
    - 세션에 로그인 했을 때의 IP를 저장 
      -> 페이지 이동 시마다, 현재 IP와 세션의 IP/브라우저 정보(UserAgent)가 같은지 검사

```
- Session과 Cookie를 사용하는 이유
현재 우리가 인터넷에서 사용하고 있는 HTTP 프로토콜은 연결 지향적인 성격을 버렸기 때문에 새로운 페이지를 요청할 때마다 새로운 접속이 이루어지며 이전 페이지와 현재 페이지 간의 관계가 지속되지 않는다. 
이에따라 HTTP프로토콜을 이용하게 되는 웹사이트에서는 웹페이지에 특정 방문자가 머무르고 있는 동안에 그 방문자의 상태를 지속시키기 위해 쿠키와 세션을 이용한다.
```

## 프레임워크와 라이브러리 차이

- 제어의 주도권이 누구한테 있는가? 가 중요한 차이점이다

- 참고사이트 : https://webclub.tistory.com/458

- 설명 잘되어있는 사이트 : http://blog.naver.com/PostView.nhn?blogId=acornedu&logNo=221030114195

- ### FrameWork (프레임워크)

  - 애플리케이션 개발에 바탕이 되는 템플릿과 같은 역할을 하는 클래스들과 인터페이스의 집합으로 공통적인 개발 환경을 제공해준다.

  - 뼈대나 기반구조를 뜻하고, **`제어의 역전`** 개념이 적용된 대표적인 기술

  - 완성된 어플리케이션이 아닌 프로그래머가 완성시키는 작업을 해야한다.

  - 객체 지향 개발을 하게 되면서 통합성, 일관성의 부족을 해결할 방법 중 하나

  - #### 특징

    - 특정 개념들의 추상화를 제공하는 여러 클래스나 컴포넌트로 구성되어 있다.
    - 추상적인 개념들이 문제를 해결하기 위해 같이 작업하는 방법을 정의한다.
    - 컴포넌트들은 재사용이 가능하다.
    - 높은 수준에서 패턴들을 조작화 할 수 있다.

- ### Library(라이브러리)

  - 자주 사용하게 되는 코드를 하나의 함수나 클래스 단위로 묶은 집합
  - 단순 활용가능한 도구들의 집합
  - 즉, 개발자가 만든 클래스에서 호출하여 사용. 
  - 클래스들의 나열로 필요한 클래스를 불러서 사용하는 방식

- #### 프레임워크와 라이브러리의 차이점

  - 차이는 '제어 흐름에 대한 주도성이 누구에게/어디에 있는가'에 있다
  - 즉, 어플리케이션의 Flow(흐름)을 누가 쥐고 있느냐에 달려 있다.
  - 프레임워크는 전체적인 실행 흐름을 스스로가 쥐고 있으며 사용자는 그 안에서 필요한 코드를 짜 넣는다.
  - 프레임워크는 그 틀안에 이미 제어 흐름에 대한 주도성이 내재(내포)하고 있다.
  - 라이브러리는 사용자가 전체적인 실행 흐름을 만들며 라이브러리를 가져다 쓴다.
  - 라이브러리는 라이브러리를 가져다가 사용하고 호출하는 측에 전적으로 주도성이 있다.



## MVC 구조란?

- Model - View - Controller의 약자로, 디자인 패턴의 하나
- 비즈니스 로직과 사용자 인터페이스를 구분시켜 서로 영향없이 개발이 가능하다는 장점이 있다.

- #### 모델(Model)

  - 어플리케이션이 "무엇"을 할 지에 대한 정의한다. 
  - 처리되는 데이터, 데이터베이스, 내부 알고리즘 등 내부 비즈니스에 관한 로직의 처리를 수행한다. 
    즉, 사용자에게 보이지 않는 로직

- #### 뷰(View)

  - 말 그대로 사용자에게 보여지는 영역이다. 
  - JSP 등 사용자 인터페이스를 담당한다.

- #### 컨트롤러(Controller)

  - 모델에게 "어떻게"할 것인지를 알려주며, 모델과 뷰 사이를 연결하는 역할을 한다. 
    사용자의 입출력을 받아 데이터를 처리한다.



## OOP, AOP, FOP 등 프로그래밍 기법

- 참고사이트 : [AOP관련](https://jojoldu.tistory.com/71)



## 객체 지향 프로그래밍

- 컴퓨터 프로그래밍 패러다임(견해, 사고법)의 하나
- 프로그래밍에서 필요한 데이터를 추상화 시켜서 상태(속성, 어트리뷰트)와 행위(메서드)를 가진 객체로 만들고, 그 객체간의 상호작용을 통해 로직을 구성하는 방법이다.

#### 장점

- 다른 클래스를 가져와 사용할 수 있고, 상속받을 수 있어 코드의 재사용성이 증가한다.
- 절차지향보다 유지보수가 간단하다.
- 클래스 단위로 모듈화가 가능하여, 대형 프로젝트에 적합

#### 단점

- 처리속도가 상대적으로 느리다.
- 객체가 많으면 용량이 커진다.
- 설계시 많은 노력과 시간이 필요하다.



### 객체 지향 프로그래밍의 특징

#### 클래스

- 현실 세계의 객체를 추상화시켜, 상태(속성)와 행위(메서드)로 정의한 것(논리적 개념)

#### 인스턴스

- 클래스에서 정의한 것을 토대로 만든, 실제 메모리상에 할당된 것, 실제 데이터

#### 다형성(Polymorphism)

- 하나의 변수명이나 함수명이 상황에 따라 다르게 해석될 수 있음

- 같은 모양의 코드가 다른 행위를 하는 것
- 오버라이딩 , 오버로딩이 있다.

#### 상속(Inheritance)

- 부모 객체의 속성과 기능을 하위 객체가 물려 받는 것 ( 코드의 재사용 )
- 다른 클래스를 가져와서 수정할 일이 있다면, 그 클래스를 직접 수정하는 대신 상속을 받아 변경하고자 하는 부분만 변경

#### 추상화(Abstraction)

- 현실 세계를 빗대어 공통의 속성이나 기능을 묶어 이름을 붙이는 것
- 공통된 속성과  행위를 추출 하는 것

#### 캡슐화(Encapsulation)

- 하나의 객체가 특정한 목적을 달성하기 위해 변수, 함수를 하나로 묶는 것
- 데이터에 접근할 때 직접적으로 접근하면 안되고 함수를 통해서만 접근할 것
- 은닉화와의 차이
  - 은닉화는 캡슐화의 일부라고 볼 수 있으며, 
    목적으로 묶인 캡슐 안을 사용자는 볼 수 없다는 것이 은닉화



## 객체지향 프로그래밍 설계 5대 원칙(SOLID)

#### Single Responsibility Principle(단일 책임 원칙) , SRP 원칙

- 객체는 단 하나의 책임만 가져야한다.

- 즉, **하나의 클래스는 하나의 기능만 수행한다.**

- 여러 클래스에서 공통적으로 사용하는 로깅, 보안, 트랜잭션 같은 기능들은 별도의 클래스로 분리하여 호출해 사용하도록 한다.

  => AOP(Aspect Oriented Programming)

- AOP는 Cross Cutting Concern(여러 클래스에서 공통적으로 수행되는 부가기능)을 Aspect라는 클래스로 분리하고, 다른 핵심 기능 클래스에서 구현(weaving)하여 사용하도록 한다.

#### Open Closed Principle(개방-폐쇄 원칙), OCP 원칙

- **기존의 코드를 변경하지 않으면서 기능을 수정할 수 있어야 한다.**
- 즉,  인터페이스에서 구체적인 수행 코드는 캡슐화해 처리하도록 해야한다.

#### Liskov Substitution Principle(리스코프 치환 원칙), LSP 원칙

- 부모클래스와 자식클래스 사이에 일관성이 있어야 한다.(일반화 관계 충족)

- `is a kind of` 관계

- 즉, **자식클래스는 최소한 부모클래스에서 수행 가능한 기능은 수행할 수 있어야 한다.**

  => 자식클래스는 부모클래스의 책임을 무시하거나 재정의 하지 않고 확장만 수행한다.

#### Interface Segregation Principle(인터페이스 분리 원칙), ISP 원칙

- 인터페이스를 클라이언트에 특화되도록 분리해야 한다.
- 클라이언트가 각각 필요한 메서드만 사용할 수 있도록 **클라이언트에 특화된 인터페이스를 설계**해야 한다.

#### Dependency Inversion Principle(의존 역전 원칙), DIP 원칙

- 클래스간 의존 관계를 맺을 때, **변하기 쉬운 것 보다는 변화가 없는 것에 의존을 하도록 설계**해야 한다.

- 즉, 변하기 어려운 추상적인 추상클래스나 인터페이스에 의존하도록 한다.

  => 의존성 주입시 구체적인 클래스보다는 추상클래스 또는 인터페이스를 주입하도록 한다.

  

- 참고 : https://gmlwjd9405.github.io/2018/07/05/oop-solid.html



### 객체 지향과 절차 지향의 차이점

- #### 절차지향 프로그래밍

  - 프로그램의 순서와 흐름을 먼저 세우고 필요한 자료구조와 함수들을 설계하는 방식

- #### 객체지향 프로그래밍

  - 반대로 자료구조와 이를 중심으로 한 모듈들을 먼저 설계한 다음에 이들의 실행순서와 흐름을 짜는 방식



#### AOP (관점 지향 프로그래밍)

- Spring Framework의 핵심 요소 중 하나. 
- 애플리케이션 전체에 걸쳐 사용되는 공통된 기능을 재사용하도록 지원하는 것
- 비즈니스 로직과 공통 모듈로 분리하고, 핵심 로직 사이사이에 공통 모듈을 잘 끼워 넣는 것을 말함.
- 이때 공통 모듈을 코드 밖에서설정된다는 것이 핵심. 인증, 로깅, 트랜잭션 처리에 용이

#### FP(함수형 프로그래밍)

- 함수형 프로그래밍은 선언형 프로그래밍으로, 어떻게(How)가 아닌 무엇(What)을 정의한다.
- C, Java등의 언어는 명령형 프로그래밍이며, 알고리즘을 기술하고 목적은 기술하지 않는다. 
- 선언형은 반대로 알고리즘은 기술하지 않고 목적 위주로 기술하며, 데이터의 입력이 주어지고 데이터의 흐름을 추상적으로 정의하는 방식

## Thread

#### Thread 생성

- Thread 클래스 상속 받은 클래스 생성

  - Thread 클래스는 Runnable 인터페이스를 구현하고 있음
  - Thread 클래스의 run() 메소드 오버라이딩

  ```java
  class MyThread extends Thread{
      public void run(){
          // 해당 스레드로 수행할 코드
      }
  }
  
  Thread t1 = new MyThread();
  ```

  

- Runnable 인터페이스 구현하는 클래스 생성

  - Runnable 인터페이스의 run() 메소드 구현
  - Thread 생성자로에 해당 Runnable 구현 객체를 파라미터로 전달하여 Thread 객체 생성

  ```java
  Thread t1 = new Thread(new Runnable(){
      public void run(){
         	// 해당 스레드로 수행할 코드
      }
  })
  ```

#### Thread 수행

- run() vs start()
  - run() 메소드는 직접 호출하지 않는다.
  - 스레드 수행을 위해서는 start() 메소드를 호출하여 run() 메소드가 호출될 수 있는 준비를 하도록한다.
  - start() 메소드를 호출하면 JVM은 운영체제의 스레드 스케줄러에 의해 해당 스레드 수행이 가능할 때 run() 메소드를 호출한다.

## Generic

- 제네릭 타입을 이용함으로써 잘못된 타입이 사용될 수 있는 문제를 컴파일 과정에서 제거할 수 있다.

- 다양한 타입의 객체를 다루는 메서드나 collection 클래스에 컴파일 시의 타입 체크를 해주는 기능
- 즉, 클래스 또는 메소드 내부에서 사용할 데이터 타입을 해당 클래스(메소드) 선언시가 아닌 인스턴스 생성시에 확정하는 것을 말한다.
- new 연산자나 static의 경우 Generic을 사용하지 못한다.
  이유 => 메모리 할당의 경우 heap영역에 충분한 공간을 확인하는데 그과정에서 타입을 알아야 한다.

#### 장점

- 타입 안정성 제공
  - 의도하지 않은 타입의 객체를 저장하는 것을 막고, 객체 리턴시 의도하지 않았던 타입으로 형변환될 수 있는 오류를 막는다.
- 코드의 간결성 제공
  - 타입체크와 형변환을 생략할 수 있다.

#### 와일드 카드(wild card)

- 제네릭타입<?> : **제한 없음**
  - 모든 클래스나 인터페이스 타입이 올 수 있다.
- 제네릭타입<? extends 상위타입> : **상위 클래스 제한**
- 제네릭타입<? super 하위타입> : **하위 클래스 제한**



## Serialization

- 자바 시스템 내부에서 사용되는 객체 또는 데이터를 외부의 자바 시스템에서도 사용할 수 있도록 Byte 형태로 데이터를 변환하는 기술 

- 역직렬화 : 바이트로 변환된 데이터를 다시 객체 형태로 변환하는 기술

- JVM 메모리의 힙 또는 스택에 상주하는 객체 데이터를 바이트 형태로 변환하는 기술을 말한다.

 

- **직렬화 조건** : primitive 타입과 java.io.Serializable 인터페이스를 상속받은 객체는 직렬화할 수 있다.

- 직렬화 방법 : ObjectOutputStream 객체를 이용하여 객체를 write한다.

```
Member member = new Member("김배민", "deliverykim@baemin.com", 25);
    byte[] serializedMember;
    try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {
        try (ObjectOutputStream oos = new ObjectOutputStream(baos)) {
            oos.writeObject(member);
            // serializedMember -> 직렬화된 member 객체 
            serializedMember = baos.toByteArray();
        }
    }
    
 // 바이트 배열로 생성된 직렬화 데이터를 base64로 변환
 System.out.println(Base64.getEncoder().encodeToString(serializedMember));
```

 

#### 역직렬화 조건 

- 직렬화 대상이 된 객체의 클래스가 클래스 패스에 존재해야하며, import 되어 있어야 한다.
- 자바 직렬화 대상 객체는 동일한 SerialVersionUID 를 가지고 있어야 한다.

- 역직렬화 방법 : ObjectInputStream 객체를 이용하여 객체를 read한다.

 

```
// 직렬화 예제에서 생성된 base64 데이터 
    String base64Member = "...생략";
    byte[] serializedMember = Base64.getDecoder().decode(base64Member);
    try (ByteArrayInputStream bais = new ByteArrayInputStream(serializedMember)) {
        try (ObjectInputStream ois = new ObjectInputStream(bais)) {
            // 역직렬화된 Member 객체를 읽어온다.
            Object objectMember = ois.readObject();
            Member member = (Member) objectMember;
            System.out.println(member);
        }
    }
```

- 문자열 형태의 직렬화 방법
  - CSV, JSON(다른 데이터 포맷 방식에 비해 오버헤드가 적기 때문에 많이 사용)

    => 라이브러리를 이용하여 직렬화 가능

 

#### **자바 직렬화를 사용하는 이유**

- CSV, JSON 같은 데이터 직렬화 형식은 시스템의 고유 특성과 상관없이 대부분의 시스템에서의 데이터 교환시 사용한다.

- 자바 직렬화 형태의 데이터 교환은 자바 시스템간의 데이터 교환을 위해 존재한다.

- 즉, 자바 시스템에서의 개발에 최적화 되어있다.
- 복잡한 데이터 구조의 클래스의 객체라도 간단하게 직렬화, 역직렬화가 가능하다.
- 데이터 타입이 자동으로 맞춰지기 때문에 편하게 사용 가능하다.

 



![img](https://k.kakaocdn.net/dn/K0orG/btqzl49X2YI/KzIB7zC8smpYl3WnuFtu3k/img.jpg)



#### **자바 직렬화를 사용하는 곳**

- JVM 메모리에 상주하는 데이터를 그대로 영속화(persistence)가 필요할 때 사용한다.

- 시스템이 종료되더라도 없어지지 않는 장점을 가지며 영속화된 데이터이기 때문에 네트워크 전송도 가능하다.

 

#### 서블릿 세션(Servlet Session)

- 서블릿 기반의 WAS들은 대부분 세션의 자바 직렬화를 지원하고 있다.

- 단순히 세션을 서블릿 메모리 위에서만 운용한다면 직렬화는 필요하지 않지만, 파일로 저장하거나 세션 클러스터링, DB를 저장하는 옵션 등을 선택하게 되면 세션 자체가 직렬화되어 전달된다.

  => 세션에 필요한 객체는 Serializable 인터페이스를 구현하는 것이 좋다.

 

#### 캐시(cache)

- 자바 시스템에서 DB 데이터를 조회한 정보를 메모리, 외부저장소 등의 캐시에 저장할 때 자바 직렬화된 데이터를 저장하도록 한다.



## 운영체제

### 멀티 스레드 환경

- 하나의 프로세스에서 다수의 실행 단위로 구분하여 자원의 생성과 관리의 중복성을 최소화하여 효율을 높이는 것을 멀티 스레딩이라고 한다.

#### 장점

- 멀티 프로세스에 비해 메모리와 자원의 소모가 줄어든다.
- 힙 영역을 사용하면 프로세스간 통신에 비해 스레드간 통신이 훨씬 간단하다.
- 스레드의 문맥전환은 캐시메모리를 비울 필요가 없어 프로세스의 문맥전환에 비해 더 빠르다.
- 그러므로, 시스템의 처리량이 늘며, 공간과 시간, 자원이 절약된다.

#### 단점

- 힙 영역을 공유하기 때문에, 해당 자원을 사용할 때 동기화를 해주어야 한다.
- 동기화를 위해 과도한 락 사용시 병목 현상때문에 성능이 저하될 수 있음

### 프로세스(스레드)의 동기화

#### 경쟁 상태(Race Condition)

- 경쟁 상태란 두 개 이상의 프로세스 혹은 스레드가 공유 자원을 동시에 사용할 때 그 순서에 따라 결과가 달라지는 문제.
- 예) 은행 잔고를 예로 입금 연산과 출금 연산을 하는데, 동시에 접근해서 연산해버리면 한 쪽 연산이 반영이 안되는 문제

#### 임계영역과 크리티컬 섹션

- ##### 임계영역(Critical Section)

  - 프로세스간 자원이 공유될 수 있는 코드 블록을 의미한다
  - 동시접근하려고 하는 포커싱된 자원에서 문제가 발생하지 않게 독점을 보장해줘야 하는 영역
- #### 임계 영역을 프로세스들이 같이 쓸 수 있는 전제 조건
1. ##### 상호 배제(Mutal Exculsion)

  - 프로세스가 크리티컬 섹션에 들어가 있다면, 다른 프로세스는 크리티컬 섹션에 들어갈 수 없다.
2. ##### 진행(progress)

  - 크리티컬 섹션에 들어가 있는 프로세스가 없다면 다른 후보 프로세스가 진입할 수 있다.
3. ##### 한정된 대기(Bounded Waiting)

  - 프로세스가 진입 가능한 횟수에는 제한이 있다(특정한 한 프로세스만 계속 진입하는 것을 방지)

#### Lock

- 하드웨어 기반 처리로, 임계 영역에 진입하기 위해서는 Lock이 필요하다.
  임계영역에 들어가는 프로세스는 Lock을 획득하고, 빠져나올때 Lock을 반납한다. 다중 처리기 환경에서 성능을 보장할 수 없다.

#### 세마포어

- 운영체제나 프로그램 내에서 공유 자원에 대한 접근을 제어하기 위해 사용되는 신호

- OS는 카운팅/이진 세마포어를 구분한다.

- ##### 카운팅 세마포어

  - 동시에 사용가능한 자원에 대해 사용되며, 임계영역 안에 스레드나 프로세스가 들어오면 카운트를 증가시켜, 일정 숫자만큼의 스레드만 사용하게 하는 것

- ##### 이진 세마포어

  - 0과 1로만 된 세마포어로, 임계영역 안에 하나의 프로세스만 들어갈 수 있다. 뮤텍스라고도 함.

##### 단점

##### Busy Waiting

- 임계 영역에 진입하려는 프로세스는 계속해서 진입하는 코드를 실행해야 한다. 
- 따라서 성능의 저하가 발생할 수 있음.
- 세마포어에서도 데드락이 발생할 수 있다.

#### 모니터

- 고급 언어의 개념으로, 추상화 메서드를 통해 동기화함. 세마포어에 비해 간단

#### 데드락

- 멀터 프로그래밍 환경에서 CPU와 같은 한정되고 공통된 자원을 사용할 때 데드락이 발생할 수 있다
- 예) 프로세스 A가 자원 1을 사용 중인 상태에서 자원 2를 사용하려고 하지만 프로세스 B가 자원2를 이미 사용하고 있어 대기중이다. 
- 그런데 프로세스 B가 자원2사용을 끝내려면 자원 1이 필요한데, 프로세스 A가 이미 자원 1을 사용하고 있기 때문에 대기해야한다. 
  즉, 서로의 자원을 쓰고 싶은데 서로가 쓰지 못하니 무한 대기상태가 걸리는데 
  이를 데드락, 교착상태라 한다.

#### 데드락의 발생 조건 4가지(모두 만족해야 함)

1. ##### 상호 배제

   - 한 자원은 한 프로세스에 의해서만 사용됨, 두 개 이상 사용 불가

2. ##### 점유 대기

   - 프로세스는 자원을 가진 채 다른 자원을 기다릴 수 있음

3. ##### 비선점

   - 다른 프로세스가 사용 중인 자원을 강제로 가져올 수 없음

4. ##### 순환 대기 

   - 프로세스의 집합에서, 각 프로세스는 순환적으로 다음 프로세스가 필요로 하는 자원을 가지고있다.

#### 데드락 해결법

1. 예방 : 4가지 조건 중 하나라도 만족되지 못하게 함
2. 회피 : 알고리즘을 데드락이 발생하지 않도록 적용
3. 회복 : 교착상태가 발생하면 그때 해결함
4. 무시 : 회복과정의 성능저하가 더 심하다면 그냥 무시함



## 스레드와 프로세스 차이

- 참고 사이트 : [프로세스와 스레드]([https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Operation%20System/Process%20vs%20Thread.md](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer Science/Operation System/Process vs Thread.md))

#### 프로세스

- cpu에 의해 처리되는 사용자 프로그램. 
- 디스크에서 메모리로 적재되어, CPU자원의 할당을 받을 수 있는 것을 말한다. 
- 프로세스에 할당되는 메모리 안에는 스택, 힙, 데이터, 코드영역을 포함한다

#### PCB 란? 

- Process Control Block의 약자로, 프로세스 제어 블록이다. 
- 프로세스에 대한 중요한 정보를 저장하고 있다. 운영체제가 프로세스를 표현한 것이라고도 한다. 
- 프로세스 생성 시 만들어지며, 주기억장치에 유지된다. 
- 문맥전환 등 다른 프로세스를 처리해야 할 때, PCB에 현재 상태를 저장함으로써 나중에 그 작업 상태를 불러와 작업 재개가 가능해진다. 
- PID, 상태, 다음 명령어 주소 등의 정보가 저장된다.

#### PC란?

- program Counter의 줄임말로, 다음에 실행될 명령어의 주소가 들어있는 레지스터이다. 
- 명령어가 인출되면, 자동으로 다음 명령어를 가리키도록 주소값이 증가된다.

#### 캐시메모리란?

- CPU의 레지스터와 메모리 사이에서 캐싱을 통해 병목 현상을 완화하는 것을 말한다.

#### 스레드

- 프로세스의 작업 실행 단위이다. 
- 즉, 멀티스레드라는 것은 한 프로세스 내에 여러개의 프로그램의 흐름을 말한다. 
- 스레드간에는 프로세스의 주소나 자원을 공유할 수 있다. 
- 스레드는 스레드 ID, PC, 레지스터 집합, 스택으로 구성된다. 
- 스레드 간에는 각자 독립적으로 작업을 수행해야 하기 때문에, 각각 스택과 PC 레지스터를 받는다.



## 동기, 비동기, 블로킹, 넌블로킹

- #### 동기화

  - 어떤 일에 대한 요청과 응답(혹은 입출력)이 동시에 이루어져야 하는 것

- #### 비동기화

  - 어떤 일에 대한 요청과 응답이 동시에 이루어질 필요 없이 따로 이루어지는 것

- #### 블로킹

  - 어떤 요청에 대한 응답이 올 때까지 대기하는 것. 즉 동기를 위해서는 블로킹이 되어야함

- #### 넌블로킹

  - 어떤 요청에 대해서 응답을 대기하지 않고 계속 루틴을 수행하는 것
  - 즉, 비동기를 위해서는 넌블로킹이 되어야 하지만, 넌블로킹이 비동기는 아니다!



## CPU 스케쥴링

#### 스케쥴러란?

-  CPU와 같은 자원을 우선순위에 기반하여 프로세스에 할당하는 방법

1. Job Queue : 현재 시스템 안에서 돌고 있는 프로세스의 집합
2. Ready Queue : 메모리 안에서 CPU의 할당을 기다리는 프로세스의 집합
3. Device Queue : 장치 입출력을 기다리고 있는 프로세스의 집합

#### 스케쥴러의 종류 3가지

1. 장기 스케쥴러(잡 스케쥴러) : 프로세스가 한꺼번에 많이 올라올 시, 메모리와 디스크 사이에서 메모리에, Ready Queue에 어떤 걸 집어넣을지 결정
2. 단기 스케쥴러(CPU 스케쥴러) : CPU와 메모리 사이에서 Ready Queue에 있는 프로세스 중 어떤 것을 CPU 할당을 받게 할지 스케쥴링
3. 중기 스케쥴러(Swapper) : 여유공간 부족 시 공간을 만들기 위해 메모리에서 쫓아내어 디스크로 옮김, 동시에 메모리가 많이 올라가는 것을 조절

#### CPU 스케쥴링 방법

1. **FCFS(First Come First Serverd)**
   - 먼저 온 녀석이 먼저 스케쥴링을 받음. 
   - 중간에 반환하지 않는 비선점형이며, 시간이 긴 프로세스가 먼저 오면 효율성이 떨어짐
2. **SJF(Short Job First)** 
   - 늦게 오더라도 수행시간이 짧은 프로세스에 먼저 할당. 
   - 이렇게 되면 수행시간이 긴 프로세스는 영원히 할당받지 못할 수 도 있음.
3. **SRT(Short Remaining Time)** 
   - 현재 프로세스의 수행시간이 끝나는 시간보다 나중에 오는 프로세스의 수행시간 완료 시간이 더 짧다면, 그 즉시 그 프로세스에게 CPU를 할당. 
   - 선점형 스케쥴링
4. **우선순위** 
   - 정수로 표현된 우선순위가 더 높은 프로세스에게 할당한다. 
   - 선점형 방식과 비선점형 방식으로 나눌 수 있는데, 선점형 방식은 우선순위가 높은 프로세스가 도달하면 그 즉시 그 프로세스에게 CPU를 할당. 
   - 비선점형 방식은 Ready Queue의 맨 앞에 그 프로세스를 등록. 
   - Starvation과 CPU를 사용못하는 프로세스를 CPU가 무한대기하는 상태가 있을 수 있음 
     => 오래 기다렸을 경우 우선순위를 높이는 Aging을 통해 해결 가능
5. **Round Robin**
   - 현대적인 CPU 스케쥴링으로, 각 프로세스는 동일한 CPU 할당 시간을 갖게 됨.
   - 할당시간 만료 시 Ready Queue 맨 뒤에 가서 줄을 섬. 
   - CPU의 사용시간이 제각각일 때 효율적. 반응 속도가 빨라지며, 공정한 스케쥴링. 
   - 주의할 점은 할당하는 시간이 너무 길다면 FCFS와 다를게 없음. 
   - 너무 작다면 잦은 컨텍스트 스위칭이 발생

## 컨텍스트 스위칭

- 멀티 프로세스 환경에서 CPU 스케줄러가 인터럽트 발생 시 현재 프로세스의 상태를 PCB에 저장하고, 새로운 프로세스의 상태를 레지스터에 저장하는 것을 말함.

## 프로세스 공간?

## 데이터베이스

- 참고 사이트 : [데이터베이스]([https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Database#%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Database#데이터베이스))

- #### 쿼리속도 및 효율 향상법

- #### 정규화

  - 참고 사이트 : https://3months.tistory.com/193

  - **정규화의 목적**
    정규화의 목적은 자료 저장 공간의 최소화
    DB내 데이터의 불일치 위험을 최소화
    자료의 수정, 삭제에 따른 예기치 않은 오류를 최소화하여 데이터구조의 안정성 최대화하는 것이 그 목적입니다.

  - **정규화의 효과**

     \- 데이터의 중복을 제거하고 데이터의 일관성을 유지할 수 있습니다.

    \- 데이터 모형의 단순화가 가능합니다.

    \- 속성의 배열 검증이 가능합니다. 즉, 식별자와 속성과의 종속성 여부를 판단할 수 있습니다.

    \- 데이터베이스 설계가 용이하며, 엔티티(Entity)와 관계(Relationship)의 누락을 방지할 수

      있습니다.

  - **정규화의 문제점**
    \- 정규화로 인한 테이블의 개수 증가로 인하여 Join이 많이 발생하여 응답속도의 지연이 있을

    ​    수 있습니다
    \- 특정시점의 정보를 표현하기 위해 이력관리 엔티티의 발생 및 업무규칙 수용 난이도가 증가

    ​    할 수 있습니다

    \- 데이터 공간의 비효율적인 활용이 발생할 수 있습니다. (제 3정규화 이상의 정규화를 수행

    ​     하는 경우)따라서 대부분 현업에서는 제 3정규화까지만을 수행하고 필요에 따라 비정규화

    ​     (Denormalization) 과정을 수행합니다

### 데이터 조작어 ( DML : Data Manipulation language )

- 데이터베이스에 들어있는 데이터를 조회하거나 변형을 가하는 조작을 위한 명령어

- SELECT , INSERT, UPDATE, DELETE

### 데이터 정의어 ( DDL : Data Definition Language )

- 테이블과 같은 데이터 구조를 정의하는데 사용되는 명령어
- CREATE, ALTER, DROP, RENAME, TRUNCATE

### 데이터 제어어 ( DCL : Data Control Language )

- 데이터베이스에 접근하고 객체들을 사용하도록 권한을 주고 회수하는 명령어
- GRANT, REVOKE

### 트랜잭션 제어어 ( TCL : Transaction Control Language )

- 논리적인 작업의 단위를 묶어서 DML에 의해 조작된 결과를 작업단위(트랜잭션) 별로 제어하는 명령어
- COMMIT, ROLLBACK, SAVEPOINT

- #### 트랜잭션 관련 참고 사이트 : https://mommoo.tistory.com/62

## 인덱스

- 키 값으로 행 데이터의 위치를 식별하는데 사용하는 기능

- 지정한 컬럼들을 기준으로 메모리 영역에 일종의 목차를 생성하는 것

- ##### 인덱스 컬럼 기준

  - 카디널리티(Cardinality) : 컬럼의 중복된 수치
  - 예] 주민번호, 계좌번호 등은 카디널리티가 높다.
  - 예] 성별, 학년 등은 카디널리티가 낮다.

## 웹 통신

- 참고 사이트 : [네트워크](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Network#웹-통신의-큰-흐름)

### GET/POST 차이

- ##### GET

  - 요청하는 데이터가 HTTP메시지의 Header 부분의 Url에 담겨 전송된다. 
  - url이라는 공간에 담겨가기 때문에 데이터의 크기가 제한적
  - 데이터가 그대로 url에 노출되므로 보안상 취약하다.

- ##### POST

  - 요청하는 데이터가 HTTP메시지의 Body부분에 담겨 전송된다.
  - GET방식보다 보안적인 측면이 낫다.

### TCP와 UDP의 비교

#### UDP(User Datagram Protocol)

- 신뢰성이 낮은 비연결형 프로토콜
- 프로토콜로 흐름제어, 오류제어 또는 손상된 세그먼트의 수신에 대한 재전송을 하지 않는다
- 라디오, TV와 같은 실시간 서비스에 사용된다.

#### TCP(Transmission Control Protocol)

- 신뢰성을 보장하는 연결형 프로코톨

- 신뢰성있는 바이트 스트림을 전송하도록 설계되었다.
- 송신자와 수신자 모두가 소켓이라고 부르는 종단점을 생성함으로써 이루어진다.
- 연결 설정은 3-way handshake를 통해 행해진다.
- **전이중방식** : 전송이 양방향으로 동시에 일어날 수 있음을 의미
- **점대점방식** : 각 연결이 정확히 2개의 종단점을 가지고 있음을 의미

#### 3-way handshake ( 연결 설정 )

1. 클라이언트는 서버에 접속을 요청하는 SYN(a) 패킷을 보낸다.
2. 서버는 클라이언트의 요청인 SYN(a)를 받고 클라이언트에게 요청을 수락한다는 ACK(a+1)와 SYN(b)를 보낸다.
3. 클라이언트는 서버의 수락응답인 ACK(a+1)와 SYN(b)를 받고 ACK(b+1)를 서버로 보내면 연결이 성립된다.

#### 4-way handshake ( 연결 해제 )

1. 클라이언트가 연결을 종료하겠다는 FIN 플래그를 전송한다
2. 서버는 클라이언트의 요청(FIN)을 받고 알겠다는 메세지 ACK를 보낸다.
2-1. 그리고나서는 데이터를 모두 보낼 때까지 잠깐 TIME_OUT이 된다.
3. 데이터를 모두 보내고 통신이 끝났으면 연결이 종료되었다고 클라이언트에게 FIN 플래그를 전송한다
4. 클라이언트는 FIN 메시지를 확인했다는 메시지(ACK)를 보낸다.
5. 클라이언트의 ACK메시지를 받은 서버는 소켓 연결을 close 한다.
6. 클라이언트는 아직 서버로부터 받지 못한 데이터가 있을 것을 대비해 일정 시간 동안 세션을 남겨놓고 잉여 패킷을 기다리는 과정을 거친다 (TIME_WAIT)



## 웹 브라우저 흐름

- 참고 사이트 : 웹 브라우저 흐름[https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Network#%EC%9B%B9-%ED%86%B5%EC%8B%A0%EC%9D%98-%ED%81%B0-%ED%9D%90%EB%A6%84](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Network#웹-통신의-큰-흐름)



## HTTP/HTTPS차이

#### HTTP의 문제점

- HTTP는 평문 통신이기 때문에 도청이 가능
- 통신 상대를 확인하지 않기 때문에 위장이 가능하다.
- 완전성을 증명할 수 없기 때문에 변조가 가능하다.

#### TCP/IP는 도청 가능한 네트워크이다.

- TCP/IP 구조의 통신은 전부 통신 경로 상에서 엿볼 수 있다. 
- 패킷을 수집하는 것만으로 도청할 수 있다. 
- 평문으로 통신을 할 경우 메시지의 의미를 파악할 수 있기 때문에 암호화하여 통신해야 한다.

#### 보안 방법

1. 통신 자체를 암호화 SSL(Secure Socket Layer) or TLS(Transport Layer Security)라는 다른 프로토콜을 조합함으로써 HTTP의 통신 내용을 암호화할 수 있다. (= HTTPS)
2. 콘텐츠를 암호화 말 그대로 HTTP를 사용해서 운반하는 내용인, HTTP메시지에 포함되는 콘텐츠만 암호화하는 것. 암호화해서 전송하면 받은 측에서는 그 암호를 해독하여 출력하는 처리가 필요하다.



## CORS 이슈

- Cross Origin Resource Sharing의 약자로 도메인 또는 포트가 다른 서버의 자원을 요청하는 매커니즘

-  동일 출처 정책(same-origin policy) 때문에 CORS 같은 상황이 발생 하면 외부서버에 요청한 데이터를 브라우저에서 보안목적으로 차단합니다.

- **해결방법**

  - 1. Access-Control-Allow-Origin response 헤더를 추가

    ```
    app.get('/data', (req, res) => {
        res.header("Access-Control-Allow-Origin", "*");
        res.send(data);
    });
    ```

    간단하게 모든 클라이언트에 요청에 대한 cross-origin HTTP 요청을 허가하는 헤더를 추가

    => 모든 응답에 일일히 추가해야하는 어려움

  - 2. Spring의 경우 Controller에 CORS 추가 => 보안적으로 취약점이 있음

## OSI 7계층이 존재하는 이유

- 통신이 일어나는 과정이 단계별로 파악할 수 있기 때문이다.
- 7단계 중 특정한 곳에 이상이 생기면 다른 단계의 장비 및 소프트웨어를 건드리지 않고도 이상이 생긴 단계만 고칠 수 있다.
- 참고 사이트 : [OSI 7계층](https://shlee0882.tistory.com/110)



## 개인 프로젝트 경험

- 진행하면서 어려웠던 점과 어떻게 극복했는지 사례를 들어 정리
- 작성방법
  - 1. 배경설명
    2. 이슈에 의한 현상 설명
    3. 왜 어려웠는지/까다로웠는지 설명
    4. 어떤식으로 문제를 해결해 나갔는지 서술-핵심문장
    5. 문제해결 및 마무리

```
경험 사례
1. 배경설명 
- 중고거래 웹사이트 '두근마켓' 프로젝트 진행시 Spring data JPA를 처음 사용하면서 Entity간의 연관관계를 다루는데 큰 어려움이 있었습니다. 
2. 이슈 현상 
- 객체들간 양방향 참조관계에서 순환 참조 현상이 있었고, POST와 PUT과 같은 데이터 변경 요청이 들어왔을 경우 참조된 객체 속성의 데이터 삽입이 되지 않는 현상이 있었다.
3. 왜 어려웠는지?
- 프로젝트 기한 내 학습해야 했기에 시간이 매우 부족하였고, 단방향,양방향의 연관관계와 테이블관계와 객체관계의 차이를 이해하는 부분에서 큰 어려움이 있었습니다.
4. 문제를 해결한 방법
- 순환 참조 현상의 경우 id값을 통해 이미 조회한 값인지 비교하는 @JsonIdentityInfo 어노테이션을 통해 무한루프를 해결하였습니다. 
- 참조된 객체 속성의 삽입의 경우, 자동으로 주입될거라 생각한 부분이 큰 오점이었으며 객체 속성 또한 repository를 활용해 직접적인 삽입이 이루어지게 코딩을 하여 해결하였다. 
5. 마무리
- 기술을 익히고자 한 시도는 좋았으나 그 과정에서 제대로된 학습을 이루지 못하고 개발한 부분에서 큰 어려움이 있었던 같다. 추후 알게된 정보로는 이러한 순환 참조를 해결하기 위해 응답 DTO를 따로만들어 데이터만 옮겨담아 return하는 법을 찾게 되었다.
```

[위의 JPA 문제해결 참고](https://velog.io/@conatuseus/연관관계-매핑-기초-1-i3k0xuve9i)



### 타인과 차별화되는 요소

- 직무를 수행해 나가는데 있어서의 강점
  - 경험을 예로들면서 이야기하면 좋을 것이다



### 창의력을 발휘한 경험

- 창의란? 
  - 완전히 새로운것을 만드는것도 있지만 서로 다른 것을 하나로 만들어 내는것?
  - 개선점을 찾아 이를 적용시킨 것도 창의라고 생각합니다. 라는 식의 정의를 해놓고 경험을 통한 답변



### 팀워크를 위해 노력했던 경험

- 두근마켓 => 비전공자 도움
- 프로젝트 시 꺼려하는 부분을 도맡아 행한점?



### 실패한 경험이 무엇이냐

- 조직 내에서 실패한 경험?
- 인생에서 실패한 경험?



#### 공백기에 무었을 했냐

- 졸업 후 취업준비하면서 자신감이 많이 떨어져 적성에 대한 고민을 했었고 관심사였던 IT와 요리 두 분야에서 고민을 했다.
- 일을하다가 적성에 안맞아 요리로 돌아서는 방향보다는 후회없는 도전을 해보고 IT분야에 확신을 세우고 싶었다. 
- 요리학교를 목표로 일본 워홀을 다녀왔고 생활하는 도중에 임금체불이라는 어려움이 생겨 한국영사관, 변호사 상담, 일본 노동청 신고 등 다양한 방법을 모색하여 해결하고자 하였습니다. 하지만 한국과는 다른 일본의 단순경고조치, 높은 변호사 선임비 등으로 모색한 방법들은 무산이 되었고, 마지막 해결책으로 매주 찾아가 최소한의 금액이라도 조금씩 받고자 노력하였습니다. 3개월이라는 긴 시간 끝에 귀국전에 체불된 임금을 다 받을 수 있었습니다. 1년이라는 일본 생활은 달성하고자한 목표는 실패했지만 힘든 상황들을 헤져나가며 극복하는 과정에서 자신감과 위기 대처 능력 등 다양한 배움을 얻을 수 있었고 도전의 가치를 크게 깨닫는 경험이었습니다.



### 마지막으로 한 마디?

- 면접관님들 ? 시간동안 면접 보시느라 고생많으셨습니다. 이번 면접을 통해 부족한 점을 알게되고 많은 것을 배운 것 같습니다. 이를 바탕으로 한 층 더 나은 개발자가 되도록 노력하겠습니다! 감사합니다!

참고 사이트 : 

[Java편 기술면접-희정블로그](https://gmlwjd9405.github.io/2017/10/01/basic-concepts-of-development-java.html)

[Spring편 기술면접-희정블로그](https://gmlwjd9405.github.io/2017/10/01/basic-concepts-of-development-spring.html)

[면접 질문 정리(웹프로그래머)](https://hahahoho5915.tistory.com/16)

[규글의 인터뷰 깃헙](https://github.com/gyoogle/tech-interview-for-developer)

[면접 질문 정리](https://daily-life-of-bsh.tistory.com/124?category=797828)

[기술 면접 준비하기]([https://velog.io/@hygoogi/%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91-%EC%A4%80%EB%B9%84%ED%95%98%EA%B8%B0](https://velog.io/@hygoogi/기술면접-준비하기))



## RestFul 이란?

- REST란 REpresental State Transfer의 약자
- 자원을 표현하여 상태를 전달한다는 뜻
- 웹에 있는 자원을 HTTP를 통하여 직관적으로 전달하기 위한 간단한 인터페이스이다.
- Restful API는 대부분의 데이터를 JSON형식이나 XML형식을 담아서 HTTP 프로토콜 위에서 통신하는 API인 것이다.
- URI를 통해 자원을 명시하고, HTTP Method(POST,GET,PUT,DELETE)를 통해 해당 자원에 대한 CRUD동작을 적용하는 것
- REST는 기본적으로 웹의 기존 기술과 HTTP 프로토콜을 그대로 활용하기 때문에 **웹의 장점을 최대한 활용할 수 있는 아키텍처 스타일이다.**
- Restful 하다는 것은 REST 법칙에 통과한 것을 말하는데, 그 법칙은 다음과 같다.
  1. 자원(Resource) : URI
     - 모든 자원에 고유한 ID가 존재하고, 이 자원은 Server에 존재한다.
     - 자원을 구별하는 ID는 '/groups/:group_id'와 같은 HTTP URI다.
     - 클라이언트는 URI를 이용해서 자원을 지정하고 해당 자원의 상태에 대한 조작을 Server에 요청한다.
  2. 메소드(Method: GET, POST, PUT, DELETE)만으로 표현
  3. 동사말고 명사만
  4. 확장자는 포함하지 않음

# Spring

#### [Spring을 사용하는 이유?](https://galid1.tistory.com/493)

- 자바 플랫폼에서 사용되는 오픈소스 웹 어플리케이션 프레임워크이다. 
- 특징으로는 가볍고, 제어의 역행을 지원하여 복잡한 부분을 개발자가 담당할 필요가 없습니다. DI, AOP를 지원합니다. 확장성이 높습니다.
- 시스템 개발시 비즈니스 로직이외의 고려할 사항(타시스템과의 연계, 분산 트랜잭션, 보안 등)들의 복잡함과 개발이 진행됨에 따라 비즈니스 로직이 복잡해지고 잦은 변경이 요구되기 때문과 같은 복잡함이 많았다 
  => 이를 해결하기 위해 스프링을 사용하고 그 중 DI, AOP, PSA가 있다

## Spring & Spring MVC & Spring Boot

#### Spring

- 자바 플랫폼을 위한 오픈소스 애플리케이션 프레임워크
- Spring의 가장 큰 특징은 DI(Dependency Injection) 이다. 
- DI와 IoC(Inversion of Control)를 활용하여 개발자는 어플리케이션의 전체 흐름에 관여하지 않고 비즈니스 로직에만 집중할 수 있다.
- 또한 Spring은 많은 Spring 모듈들을 이용해서 다양한 기능을 제공한다.
  - Spring JDBC
  - Spring AOP
  - Spring MVC
  - Spring ORM
  - Spring Test

#### Spring MVC

- Dispatcher Servlet, ModelAndView, View Resolver와 같은 개념을 이용해서 웹 어플리케이션 개발을 쉽게 할 수 있도록 도와준다.

#### Spring Boot

- Spring 어플리케이션의 경우 다양한 bean에 대한 설정을 해주어야한다.(XML 또는 JAVA 코드)
  - component scan(DTO, DAO, Service)
  - Dispatcher Servlet
  - View Resolver
  - 등등
- Auto Configuration
  - classpath 상에 사용가능한 프레임워크와 이미있는 환경 설정을 기반으로 기본환경 설정을 제공한다.
  - 예를들어, MySQL jar가 클래스패스 상에 있을 경우 Datasource를 자동으로 구성한다.
  - 또한, Spring MVC jar가 클래스패스 상에 있을 경우 Dispatcher Servlet을 자동으로 구성한다.
- 의존 라이브러리나 프레임워크의 버전 관리
  - 기존에는 웹 어플리케이션에 필요한 Spring MVC, Jackson Databind 같은 라이브러리 또는 프레임워크를 의존할 때, 모든 프레임워크들이 호환되는 버전을 선택해야 했다.
  - Spring boot는 pom.xml에 의존할 라이브러리나 프레임워크 종속성만 포함시키고 바로 진행할 수 있게한다.(알아서 버전 관리를 해준다.)

참고 : http://blog.naver.com/PostView.nhn?blogId=sthwin&logNo=221271008423&parentCategoryNo=&categoryNo=50&viewDate=&isShowPopularPosts=true&from=search



### Spring MVC에서의 컴포넌트

View - JSP, Controller - Java Class, Model - JavaBean

- #### 컨테이너(Container) 란?

  - 프레임워크 안에서 인스턴스들의 생명주기를 관리하며, 생성된 인스턴스들에게 추가적인 기능을 부여한다. 
  - 내가 작성한 코드의 처리과정을 컨테이너에서 수행한다. 
  - 스프링 컨테이너는 스프링 프레임워크 핵심에 위치하여 DI를 통해 애플리케이션을 구성하는 컴포넌트들을 관리한다.

- #### IOC 란?

  - Inversion Of Control, 제어의 역전이라는 뜻
  - 인스턴스의 생성 및 소멸을 개발자 대신 스프링 컨테이너가 한다.
  - 그외 제어권을 프레임워크에서 가져간다는 말로도 쓰인다.

- #### DI 란?

  - Dependency Injection, 의존성 주입이라는 뜻
  - IOC를 실제로 구현하는 방법. 
  - 의존성이 있는 컴포넌트를 개발자가 코드로 명시하는 것이 아니라 Spring이 런타임에서 연결해 처리해준다. 
  - XML파일을 통해 설정한대로, Bean객체 생성 시 의존성 주입을 수행한다.

- #### Web Browser 흐름

  1. 요청된 URL을 Dispatcher-servlet에 전달 
  2. 핸들러 매핑은 해당 URL에 매핑된 컨트롤러가 있는지 검사 후 컨트롤러에 전달 
  3. 해당 컨트롤러가 로직을 처리 
  4. 결과를 ModelAndView 객체 생성 후 담아 Dispatcher-servlet에 전달 
  5. Dispatcher-servlet은 전달 받은 View(jsp)가 있는지 검사하기 위해 ViewResolver로 보냄 
  6. ViewResolver는 받은 View(jsp)가 있는 지 검사 후 View로 보냄 
  7. View에서 Model과 같이 View(jsp)를 그린 후에 Dispatcher-servlet으로 전달 
  8. 최종적으로 컨텐츠를 클라이언트에게 전달

- #### Bean 객체란?

  - 자바에서의 POJO(Plain Old Java Object)로,
  - XML 설정파일을 통한 생명주기, 종속성 등의 메타데이터를 가지고 스프링 컨테이너에서 생성된 객체이다. 
  - 컨테이너에서 생성되었다는 점을 제외하면 일반 자바객체와 같다.

  

## DI(Dependency Injection)

#### Java Bean VS Spring Bean

- Java Bean은 데이터를 표현하는 것을 목적으로 하는 자바 클래스
  - 생성자, getter/setter 를 가지고, 직렬화가 가능한 클래스
- Spring Bean은 Spring container에 의해 등록, 생성, 조회, 관계 설정이 되는 객체
  - 즉, IoC 방식으로 관리되는 객체를 말한다.

#### 일반적인 의존 관계와 의존 역전 원칙

- 일반적인 의존 관계
  - 일반적인 프로그램의 흐름에 따라 객체 내에서 필요한 객체가 있을 때, 필요한 객체를 직접 생성하고, 직접 객체의 메소드를 호출한다.
  - 즉, 모든 작업은 사용하는 쪽에서 제어한다.
- 의존 역전 원칙(DIP, Dependency Inversion Principle)
  - 객체 내에서 필요한 객체가 있을 때, 직접 객체를 생성하는 것이 아니라, 생성된 객체를 받아서 사용한다.
  - 또한 사용할 객체의 구현 클래스가 아닌 인터페이스를 사용함으로써 실제 객체가 어떤 타입이든 관계없이 같은 코드를  사용할 수 있다.
  - 즉, 객체간의 의존 관계가 뒤집어진 의존 역전 원칙이 되는 것이다.

#### BeanFactory & ApplicationContext

- BeanFactory
  - Bean을 생성하고 관리하는 인터페이스
  - 클라이언트의 요청이 있을 때 객체를 생성한다.(lazy-init)
- ApplicationContext
  - BeanFactory 인터페이스를 상속받은 인터페이스
  - 컨테이너가 구동되는 시점에 등록된 Bean 객체들을 모두 스캔하여 생성한다.(eager init)

#### Annotation

- 컴파일러를 위한 정보를 제공하기 위한 용도

- bean 등록 annotation
  - `@Bean` : 개발자가 컨트롤할 수 없는 외부 라이브러리 bean을 등록하고 싶은 경우
  - `@Component` : 개발자가 직접 만든 클래스를 bean으로 등록하고 싶은 경우
  - `@Controller` `@Service` `@Repository` : 클래스의 기능에 따라 명칭을 다르게 부여한 bean
- bean 주입 annotation
  - `@Autowired` : 타입으로 참조할 bean을 찾아 주입
    - `@Qualifier`  : 같은 인터페이스를 구현한 클래스가 여러개 일때, 이름으로 구별해주기 위한 annotation
  - `@Resource` : 이름으로 참조할 bean을 찾아 주입

#### Bean 생성 순서

- 의존 관계가 있는 경우

  - 각 Bean들이 순서대로 생성, 초기화된다. 

    - Spring에서는 web.xml에 선언된 순서대로
    - Spring boot 에서는 패키지 순서대로 

  - Bean 생성 중 의존하고 있는 Bean이 존재할 때 

    - 의존하는 Bean이 아직 생성되지 않은 경우 먼저 해당 Bean을 생성 및 초기화 한다.

    - Spring Container에 등록되지 않은 bean(xml 설정 파일이나 어노테이션이 없는 bean)은 Spring Container가 spring bean으로써 관리할 수 없기 때문에, 해당 bean을 생성하는 시점에 의존하고 있는 bean이 생성되지 않아도 먼저 생성해주지 않는다.

      => 의존하는 bean이 null 값이 되는 경우가 발생할 수 있다.

- 참고 : https://sehun-kim.github.io/sehun/springbean-lifecycle/

  

## IoC(Inversion of Control)

#### Spring Container

- Spring Container는 개발자가 작성한 코드의 처리과정을 위임받아 독립적으로 처리하는 컨테이너이다.

- 사용하는 이유

  - 이전까지는 클래스 내에서 다른 객체를 사용하고 싶을 때 직접 new 연산자로 객체를 생성하고, getter/ setter로 값을 관리하여야 했다.

  - 이는 높은 의존성과 결합도를 가지게 된다.

    - 프로그램 내에서 서로 생성하고 참조하는 객체가 많아지게 된다.
    - 즉, 참조되는 객체의 구현이 바뀌게 되면 그 객체를 참조하고 있는 객체에서의 생성과 호출(사용)도 바뀌어야 한다. => 의존성이 높다.

  - OOP는 낮은 의존성과 높은 캡슐화를 지향하기 때문에 의존성을 낮추기 위해 Spring Container를 사용한다.




### 싱글톤 패턴

- 다중 스레드의 경우 인스턴스가 1개 이상 생성되는 경우가 발생할 수 있다.

참고 사이트 : https://gmlwjd9405.github.io/2018/07/06/singleton-pattern.html

```java
1. 정적 변수에 인스턴스를 만들어 바로 초기화하는 방법
/* static 변수
- 객체가 생성되기 전 클래스가 메모리에 로딩될 때 만들어져 초기화가 한 번만 실행된다.
- 프로그램 시작~종료까지 없어지지 않고 메모리에 계속 상주하며 클래스에서 생성된 모든 객체에서 참조할 수 있다. 
*/

public class Singleton {
	private static Singleton single = new Singletion();
	private Singleton() {}
	public static Singleton getSingleton() {
		return single;
	}
	public void print(String str) {
		System.out.println(str);
	}
}

2. 인스턴스를 만드는 메서드에 동기화하는 방법
/* 인스턴스를 만드는 메서드를 임계 구역으로 변경
- 다중 스레드 환경에서 동시에 여러 스레드가 getPrinter 메서드를 소유하는 객체에 접근하는 것을 방지한다.
- 공유 변수에 접근하는 부분을 임계 구역으로 변경
- 여러 개의 스레드가 하나뿐인 counter 변수 값에 동시에 접근해 갱신하는 것을 방지한다.
- getInstance()에 Lock을 하는 방식이라 속도가 느리다.
*/
public class Singleton {
	private static Singleton single = null;
	private int counter = 0;
	private Singleton() {}
	// 인스턴스를 만드는 메서드 동기화 ( 임계 구역 )
	public synchronized static Singleton getSingleton() {
		if(single == null) {
			single = new Singleton();
		}
		return single;
	}
	public void print(String str) {
		// 오직 하나의 스레드만 접근을 허용함 ( 임계 구역 )
		// 성능을 위해 필요한 부분만을 임계 구역으로 설정한다.
		synchronized(this) {
			counter++;
			System.out.println(str + counter);
		}
	}
}
```



## Servlet

#### Servlet Container

![img](https://i.imgur.com/alHA0zr.jpg)

- servlet container는 servlet의 생성부터 소멸까지의 life cycle을 관리한다.
- 클라이언트의 요청이 들어올 때마다 새로운 자바 스레드를 생성한다.(thread per request)
- 웹 서버와 통신하기 위해 개발자가 직접 소켓을 생성하고, 특정 포트를 listening 하고 stream을 생성하는 등의 구현을 하지 않아도 된다.
- 대표적인 servlet container : tomcat
- Servlet 동작과정
  - 사용자가 특정 url을 클릭하면 클라이언트 서버는 HTTP Request를 servlet container에 보낸다.
  - servlet container는 HttpServletRequest, HttpServletResponse 두 객체를 생성한다.
  - 요청 URL을 분석하여 해당 url에 매핑되는 서블릿을 찾는다.
  - 해당하는 서블릿의 service() 메소드를 호출하여 요청 메소드에 따라 doGet() 또는 doPost() 메소드가 호출된다.
  - doGet() / doPost() 메소드 내에서 동적 페이지를 생성 후 HttpServletResponse 객체에 응답을 보낸다.
  - 응답이 완료되면 HttpServletRequest, HttpServletResponse 객체를 소멸시킨다.



#### Servlet과 Thread

- 사용자의 하나의 요청에 대해 하나의 새로운 스레드가 생성되고, 서블릿이 수행된다.

- 즉, 서블릿은 스레드 안에서 작동한다.

- Servlet 3 이상부터 스레드 사용 방식을 `thread per request` 로 관리한다.

  - thread가 매 클라이언트의 접속마다 할당되는 것이 아니라, 일정 크기의 thead pool 안에서 제공되는 thread를 클라이언트 요청마다 재사용하는 것이다.

    - thread pool은 스레드를 무한정으로 생성하다가 제한된 운영체제의 자원에 의해 스레드 고갈 현상이 발생하는 것을 막는다.

    - 즉, 일정 개수 만큼의 스레드를 미리 만들어놓고, 클라이언트의 요청이 들어올 때마다 무한 재사용한다. 

      => 스레드를 운영체제에 반납하지 않고 계속 재사용하기 때문에 스레드 생성 비용도 줄일 수 있다.

  - 한 클라이언트의 요청에 대해서 한 스레드가 요청-응답 과정을 처리한다.

    - 클라이언트의 요청을 처리하는 스레드에서 클라이언트에 전송할 응답을 생성한다.
    - 즉, 여러 클라이언트 요청에 대해서 멀티 스레드로 동작하지만, 각 스레드는 blocking 되어있어 각 클라이언트의 작업은 synchronous하게 수행된다.
    - 하나의 서버에 대해서 동시 접속자가 많아 서블릿의 동시호출이 많이 발생하고, 서블릿의 수행 속도가 느려지게 되면 thread pool의 모든 thread가 소비되어 다른 접속자들이 더이상 스레드를 사용할 수 없게되는 문제점이 생긴다.

- 비동기 서블릿의 사용

  - 일반적인 웹에서는 요청을 보내고 응답을 받으면 서버와의 연결을 종료시킨다.

    - 그러나, 채팅 프로그램 같은 경우 클라이언트와 서버가 연결을 계속 유지한 채 server push가 이루어져야 한다.
    - thread pool의 스레드는 한정되어 있기 때문에 일부 클라이언트가 연결을 유지하면서 스레드를 모두 사용하면 다른 클라이언트들에게 서비스를 제공할 수 없게 된다.

  - 비동기 서블릿은 클라이언트에 대한 응답을 별도 스레드로 처리하도록 한다.

    - 서블릿의 doGet() / doPost() 메소드 내에서 새로운 스레드를 생성하여 응답을 수행하도록 한다.

      - 비동기로 요청을 처리하기 위한 AsyncContext 객체를 HttpServletRequest 객체의 startAsync() 메소드를 이용하여 생성한다.

      - 서블릿이 종료되더라도 AsyncContext 객체를 활용하여 HttpServletReponse 객체를 생성할 수 있고, 응답을 처리할 수 있다.

      - AsyncContext 객체는 스레드가 아니다. 

        - 서버에서 클라이언트에 언제든지 server push 할 수 있도록 응답 객체를 가지고 있을 뿐이다.

          (하나의 스레드(채팅방)에 여러개의 AsyncContext 객체(채팅 참여 클라이언트)를 포함시켜 동기화시킬 수 있다.)

        - 클라이언트에 대한 응답이 완료되거나 타임아웃이 발생하면 complete() 메소드로 클라이언트와의 연결을 종료하게 된다.

  ```java
  @WebServlet(urlPatterns = "/hello", asyncSupported = true)
  public class AsyncHelloWorldServlet extends HttpServlet {
  
      private Logger logger = Logger.getLogger(getClass());
      
      @Override
      protected void doGet(HttpServletRequest req, HttpServletResponse res)
              throws ServletException, IOException {
          final AsyncContext asyncContext = req.startAsync();
  
          new Thread(new Runnable() {
              @Override
              public void run() {
                  try {
                      Thread.sleep(5000);
                  } catch (InterruptedException e) {}
                  
                  HttpServletResponse response = 
                      (HttpServletResponse) asyncContext.getResponse();
  
                  response.setContentType("text/plain");
              	response.setCharacterEncoding("UTF-8");
  
                  try {
                      response.getWriter().println("HELLO");
                  } catch (IOException e) {
                      e.printStackTrace();
                  }
  
                  logger.info("complete response");
                  asyncContext.complete();
              }
          }).start();
        
          logger.info("doGet return");
      }
  }
  ```

- 참고 

  - https://javacan.tistory.com/entry/Servlet-3-Async
  - [https://github.com/dalcomlab/waffle-java/wiki/%5B%EC%84%9C%EB%B8%94%EB%A6%BF%5D%EB%B9%84%EB%8F%99%EA%B8%B0-%EC%84%9C%EB%B8%94%EB%A6%BF-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D%EC%97%90-%EB%8C%80%ED%95%9C-%EC%A0%95%EB%A6%AC-%E2%80%93--%231](https://github.com/dalcomlab/waffle-java/wiki/[서블릿]비동기-서블릿-동작-방식에-대한-정리-–--%231)

  

## JSP

#### MVC1 패턴과 MVC2 패턴

- MVC1 패턴

  - 모든 클라이언트의 요청과 응답을 JSP가 담당한다.
  - 즉, JSP에 view 코드(html)와 controller 코드(java)가 함께 존재한다.
  - 각 코드의 재사용성이 떨어져 유지보수가 어려워지고 효율성이 떨어진다.

- MVC2 패턴

  - controller 역할은 servlet이, view 역할은 JSP가 담당한다.

  - 서블릿이 클라이언트의 요청을 받아 처리 후 결과를 JSP 페이지에 포워딩 한다.

  - 코드의 유지보수 및 확장이 용이하다.

    

## Spring MVC

#### Servlet과 Spring MVC

- Servlet은 J2EE 프레임워크의 일부이며, 모든 JAVA 어플리케이션 서버(tomcat 등)는 서블릿을 실행하기 위해 빌드된다.

  - Servlet은 Web Server의 요청을 동적으로 처리 가능한 자바 클래스이다.
  - 하나의 Servlet 클래스는 하나의 URL과 매핑된다.
    - 하나의 클래스에서 여러 URL을 처리하기 위해서는 파싱하여 분리하는 복잡한 방법을 사용해야 한다.
  - 미리 패키징 되어있기 때문에 Servlet.jar 가 필요하지 않다.

- Spring MVC는 MVC 패턴을 적용하여 좀 더 쉽게 개발을 하기 위해 사용되는 Servlet 위에 구축된 라이브러리이다.

  (Spring에서 제공하는 다양한 모듈 중 하나)

  - Form 데이터 parameter, 컨트롤러 메서드의 parameter 매핑, 바이너리 form 제출, bean 변환 등을 쉽게 처리할 수 있는 기능들을 제공한다.
  - 하나의 클래스에서 여러 URL과 매핑되는 여러 메소드를 관리할 수 있다.
  - Spring 컨트롤러를 실행하려면 필요한 jar 파일을 패키징 해야한다.

- 즉, Servlet은 Java Application의 Low 레벨에서 동작하고, Spring MVC는 그것 보다는 High 레벨에서 동작한다고 할 수 있다.

  

#### Spring Container

- 어플리케이션의 Bean들의 생명주기를 관리하는 컨테이너

  => 개발자가 직접 인터페이스 호출하거나 new 연산자로 객체 생성 등을 통해 의존성을 만들지 않아도 된다.

- bean을 관리하기 위해 DI(Dependency Injection)를 사용한다.



#### 웹 어플리케이션 동작 원리

![img](https://i.imgur.com/PlDF42i.png)

- Dispatcher servlet : 서블릿 컨테이너에서 HTTP 프로토콜을 통해 들어오는 모든 클라이언트의 요청을 presentation 계층의 제일 앞에서 중앙집중식으로 처리해주는 Front Controller 역할

  - `servlet-context.xml` 을 로딩하여 Controller bean들을 포함하는 Spring Container를 생성한다.
  - 기존의 servlet
    - web.xml에 servlet과 url 패턴을 등록하고 매핑하는 과정이 필요하다.
    - 즉, url 당 새로운 servlet을 생성하여 요청을 처리해야 했다.

- Front Controller

  - 하나의 Servlet에서 모든 요청을 받아들여 적절한 controller로 요청을 위임해준다.

- ContextLoaderListener 

  - DAO, DTO, Service 등 controller가 공유하는 bean들을 포함하는 Spring Container를 생성한다.

  - bean에 대한 설정 파일 `root-context.xml` 을 로딩 후 생성한다.

  - DispatcherServlet에 의해 생성된 bean(controller)은 ContextLoaderListener에 의해 생성된 bean을 참조할 수 있다.

    ![img](https://gmlwjd9405.github.io/images/web/springmvc-contextLoadListener.png)

- 참고 

  - https://minwan1.github.io/2017/10/08/2017-10-08-Spring-Container,Servlet-Container/
  - https://gmlwjd9405.github.io/2018/10/29/web-application-structure.html



## Error Handling

#### BasicErrorController

- Spring boot에서는 기본적인 에러 처리를 하는 BasicErrorController를 제공한다.
- 요청한 HTTP의 Accept 헤더에 text/html 이 포함된 경우엔 html 뷰를 반환하고, 그 외는 JSON 객체를 반환한다.
- 일반적인 spring boot의 페이지 404 에러시 나오는 whitelabel error page는 BasicErrorController에서 반환한 html 뷰이다.

```java
// text/html가 포함된 헤더가 있는 요청에는 뷰를 반환
@RequestMapping(produces = {"text/html"})
public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) {
    HttpStatus status = this.getStatus(request);
    Map<String, Object> model = Collections.unmodifiableMap(this.getErrorAttributes(request, this.isIncludeStackTrace(request, MediaType.TEXT_HTML)));
    response.setStatus(status.value());
    ModelAndView modelAndView = this.resolveErrorView(request, response, status, model);
    return modelAndView != null ? modelAndView : new ModelAndView("error", model);
}

// 그 외에는 json 객체를 반환
@RequestMapping
  public ResponseEntity<Map<String, Object>> error(HttpServletRequest request) {
      Map<String, Object> body = this.getErrorAttributes(request, this.isIncludeStackTrace(request, MediaType.ALL));
      HttpStatus status = this.getStatus(request);
      return new ResponseEntity(body, status);
  }
```



#### @ExceptionHandler

- @Controller 어노테이션으로 선언된 컨트롤러 내의 메소드에서 발생한 Exception을 처리한다.

  ```java
  @Controller public class SimpleController { 
      // ... 
      @ExceptionHandler 
      public ResponseEntity<String> handle(Exception ex) { 
          // ... 
      } 
  }
  ```

- Exception 마다 처리 방식이 다를 경우, @ExceptionHandler에 대상 Exception 목록을 지정하여 각각 처리할 수 있다.

  ```java
  @ExceptionHandler({FileSystemException.class, RemoteException.class})
  ```



#### @ControllerAdvice

- @Controller에 정의된 @ExceptionHandler는 해당 컨트롤러에서만 동작한다.

- 모든 컨트롤러에서 공통적으로 처리할 에러가 있을 경우

  - @ControllerAdvice 어노테이션으로 선언된 컨트롤러에서 @ExceptionHandler 를 선언하여 모든 컨트롤러에 대해 발생한 전역 에러 처리를 할 수 있다.

  ```java
  @Controller 
  @ControllerAdvice 
  public class GlobalExceptionController { 
      // ... 
      @ExceptionHandler 
      public ResponseEntity<String> handle(IOException ex) { 
          // ... 
      } 
  }
  ```

- 컨트롤러 대상을 좁히고 싶을 경우 어노테이션, 패키지, 클래스 기준으로 지정해서 사용할 수 있다.

  ```java
  @ControllerAdvice(annotations=RestController.class)
  @ControllerAdvice("com.hs.reivew.controller")
  @ControllerAdvice(assignableTypes = {ControllerInterface.class})
  ```

  

## Filter VS Interceptor

![img](https://t1.daumcdn.net/cfile/tistory/9983FB455BB4E5D30C)

#### Filter

- Dispatcher Servlet의 앞단에서 클라이언트의 요청과 응답을 처리하는 역할

- J2EE 표준 스펙에 정의되어있는 기능

  - 즉, Servlet Container에 의해 동작이 제어되는 Java class이다.
  - Spring Framework와는 무관하게 지정된 자원에 대해서 동작한다.

- 주로 전역적으로 무언가 처리해야하는 로직을 구현할 때 사용한다.

  - ex) 인코딩, 보안 처리(XSS)

- Filter chain을 가지고 순서대로 동작한다.

  ```java
  public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
      /**
          filtering 로직 구현 
      */
  
      // 해당 필터의 처리 결과를 다음 필터로 넘겨주는 역할
      // 다음 필터가 없다면 서블릿으로 전달
      filterChain.doFilter(servletRequest, servletResponse);
  }
  ```

- web.xml 또는 Java configuration을 이용해 구현한다.

  

#### Interceptor

- Spring Context 내에서 HttpRequest와 HttpResponse를 처리하는 역할
  - Dispatcher Servlet에서 Controller로 요청이 넘어가기 전 처리된다.
  - Spring 내의 모든 bean에 접근할 수 있다.
- 인증, 권한, 업로드 파일 처리 등의 디테일한 로직을 구현할 때 사용한다.
- ServletContext.xml 또는 Java configuration을 이용해 구현한다.